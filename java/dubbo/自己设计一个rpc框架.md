# 如何自己设计一个RPC框架

首先明确下一个RPC调用中的几个角色：

* Client：服务的调用者
* Client Stub：客户端存根，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。
* Server：服务提供者
* Server Stub：服务端存根，接收客户端发送过来的消息，将消息解包，并调用本地的方法。

### 技术选型

* 序列化/反序列化
    
    首先排除Java的ObjectInputStream和ObjectOutputStream，因为不仅需要保证需要序列化或反序列化的类实现Serializable接口，还要保证JDK版本一致，公司应用So Many，使用的语言也众多，这显然是不可行的，考虑再三，决定采用Objesess。

* 通信技术

    Netty


* 高并发技术
    
    远程调用技术一定会是多线程的，只有这样才能满足多个并发的处理请求。这个可以采用JDK提供的Executor。


* 服务注册与发现
    
    Zookeeper。当Server启动后，自动注册服务信息（包括host,port,还有nettyPort）到ZK中；当Client启动后，自动订阅获取需要远程调用的服务信息列表到本地缓存中。


* 负载均衡
    
    分布式系统都离不开负载均衡算法，好的负载均衡算法可以充分利用好不同服务器的计算资源，提高系统的并发量和运算能力。


* 非侵入式
    
    借助于Spring框架，spring-aop，基于注解的方式。

### 分布式

RPC整体的思想是：为客户端创建服务代理类，然后构建客户端和服务端的通信通道以便于传输数据，服务端的话，就需要在接收到数据后，通过反射机制调用本地服务获取结果，继续通过通信通道返回给客户端，直到客户端获取到数据，这就是一次完整的RPC调用。

* 服务的注册和发现

    当Server端启动后，自动将当前Server所提供的所有带有@ZnsService注解的Service Impl注册到Zookeeper中，在Zookeeper中存储数据结构为 ip:httpPort:acceptorPort。
    
    当Client端启动后，根据扫描到的带有@ZnsClient注解的Service Interface从Zookeeper中拉去Service提供者信息并缓存到本地，同时在Zookeeper上添加这些服务的监听事件，一旦有节点发生变动（上线/下线），就会立即更新本地缓存。
    
* 负载均衡
  
    我们的提供者往往会有多个，负载均衡策略决定你选择提供者的方式，最基础的有随机选择，线性轮训，甚至可以根据提供者的处理成功次数来做选择。

* 并发请求和异步回调

    服务调用者可以并发发起多个请求，同时返回结果的响应可以异步化，通过回调处理。
